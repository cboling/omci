/*
 * Copyright (c) 2018 - present.  Boling Consulting Solutions (bcsw.net)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * NOTE: This file was generated, manual edits will be overwritten!
 *
 * Generated by 'goCodeGenerator.py':
 *              https://github.com/cboling/OMCI-parser/README.md
 */

package generated

import (
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"
)

// IConstraint is an interface for attribute value comparison
type IConstraint interface {
	// valid returns true if a value matches the defined constraint
	Valid(value interface{}) bool
}

// UintConstraint is use for discrete valued integers, enumerations, and pointer constraints
type UintConstraint struct {
	Value uint64
}

// Valid returns true if the value equal to the fixed value of this constraint
func (c *UintConstraint) Valid(value interface{}) bool {
	var u64Value uint64

	switch value.(type) {
	default:
		return false

	case uint, uint8, uint16, uint32, uint64:
		u64Value = reflect.ValueOf(value).Uint()

	case int, int8, int16, int32, int64:
		iValue := reflect.ValueOf(value).Int()
		if iValue < 0 {
			return false
		}
		u64Value = reflect.ValueOf(uint(iValue)).Uint()
	}
	return u64Value == c.Value
}

// UintMaxMinConstraint are integer and enumerations that have a contiguous range of values that
// are considered valid. Used also by enumerations and pointers.
type UintMaxMinConstraint struct {
	Min uint64
	Max uint64
}

// Valid returns true if the value is [min..max]
func (c *UintMaxMinConstraint) Valid(value interface{}) bool {
	var u64Value uint64

	switch value.(type) {
	default:
		return false

	case uint, uint8, uint16, uint32, uint64:
		u64Value = reflect.ValueOf(value).Uint()

	case int, int8, int16, int32, int64:
		iValue := reflect.ValueOf(value).Int()
		if iValue < 0 {
			return false
		}
		u64Value = reflect.ValueOf(uint(iValue)).Uint()
	}
	return c.Min <= u64Value && u64Value <= c.Max
}

// BitmapConstraint are bitmasks that only specific bits set or cleared
type BitmapConstraint struct {
	Bitmask uint64
}

func (c *BitmapConstraint) Valid(value interface{}) bool {
	var u64Value uint64

	switch value.(type) {
	default:
		return false

	case uint, uint8, uint16, uint32, uint64:
		u64Value = reflect.ValueOf(value).Uint()

	case int, int8, int16, int32, int64:
		iValue := reflect.ValueOf(value).Int()
		if iValue < 0 {
			return false
		}
		u64Value = reflect.ValueOf(uint(iValue)).Uint()
	}
	return u64Value&c.Bitmask == u64Value
}

// OctetConstraint are octet/byte strings that have may have a fixed size and possibly
// a regular expression it must match. Table rows are also modeled by OctetConstraint
//
//  len(<values>)[,regex(<allowed-pattern>)][,fill(<value>)]
type OctetConstraint struct {
	Length int            // Fixed length, if zero the length may vary or is not constrained/specified
	RegEx  *regexp.Regexp // Regular expression (optional)
	Fill   *byte          // Optional fill value. Not used in constraint checks at this time
}

func (c *OctetConstraint) lengthValid(value []byte) bool {
	if c.Length == 0 {
		return true
	} else if value == nil {
		return false
	}
	return len(value) == c.Length
}

func (c *OctetConstraint) regExValid(value []byte) bool {
	if c.RegEx == nil {
		return true
	}
	return c.RegEx.Match(value)
}

func (c *OctetConstraint) Valid(value interface{}) bool {
	var u8String []byte
	switch value.(type) {
	default:
		return false

	case string:
		u8String = []byte(value.(string))

	case []byte:
		u8String = value.([]byte)
	}
	return c.lengthValid(u8String) && c.regExValid(u8String)
}

func (c *OctetConstraint) parseLength(input string) int {
	return 0
}

func (c *OctetConstraint) parseRegEx(input string) *regexp.Regexp {
	if len(input) == 0 {
		return nil
	}
	return regexp.MustCompile(input)
}

// NewOctetsConstraints parses an input string and generates an appropriate IConstraint type
// to handle processing.  The input takes on the form of:
//
//   [len(<values>)][,regex(<allowed-pattern>)][,fill(<value>)]
//     where:
//       len()    is a function that checks a string/octets for a specific length and the
//                result should match one of the <values>.  For tables, this is the length
//                of a row entry.  If not specified, the octet/string/table row can be any
//                length.
//
//       regex()  is an optional regular expression that will check the values of
//                the collection of octets. Any pattern is provided
//
//       fill())  is an optional fill value to add to the end of a supplied string so that
//                the entire string length is set to the maximum allowed. Typically this is
//                either an ASCII space (0x20) or a null (0x00).
//
func NewOctetsConstraint(input string) IConstraint {
	var constraint *OctetConstraint
	values := strings.Split(strings.TrimSpace(input), ",")

	// Maximum of 3 possible fields
	if len(values) > 3 {
		panic(fmt.Sprintf("Invalid Octet Constraint. Max fields = 3, '%v'", input))
	}
	if len(values) > 0 {
		lenFilter := regexp.MustCompile("len\\([0-9]+\\)")
		// TODO: -> regExFilter := regexp.MustCompile(")")
		index := 0
		tmpLen := []byte(strings.Replace(values[index], " ", "", -1))
		if lenFilter.Match(tmpLen) {
			// Length matched

			index++
		}
		// TODO: -> tmpReg := []byte(strings.Replace(values[index], " ", "", -1))
		// TODO: -> if regExFilter.Match(tmpReg) {
		// TODO: -> 	// Length matched
		// TODO: -> 	index++
		// TODO: -> }
	}
	//
	//if len(input) > 0 {
	//	for _, value := range values {
	//		constraint := NewIntegerConstraint(value)
	//		if constraint != nil {
	//			constraints = append(constraints, constraint)
	//		}
	//	}
	//}
	return constraint
}

// NewIntegerConstraintList parses an input string containing multiple interger constraints
// and generates an appropriate array of IConstraint.  The input takes on the form of:
//
//   <values>
//     where <values> is a pattern of one or more numbers as indicated below.
//       <value>                   a single numerical value
//       <min-value>..<max-value>  a range of values with the min/max specified
//
//     Multiple value fields can be specified and are separated by commas
//     such as:      2, 4..16, 255
//
func NewIntegerConstraintList(input string) []IConstraint {
	values := strings.Split(strings.TrimSpace(input), ",")
	constraints := make([]IConstraint, 0)

	for _, value := range values {
		constraint := NewIntegerConstraint(value)
		if constraint != nil {
			constraints = append(constraints, constraint)
		}
	}
	if len(constraints) == 0 {
		constraints = nil
	}
	return constraints
}

// NewIntegerConstraint parses an input string and generates an appropriate IConstraint type
// to handle processing.  The input takes on the form of:
//
//   <input>
//     where <input> is one of the following:
//       <value>                   a single numerical value
//       <min-value>..<max-value>  a range of values with the min/max specified
//
func NewIntegerConstraint(input string) IConstraint {
	input = strings.TrimSpace(input)
	if len(input) == 0 {
		return nil
	}
	if strings.Contains(input, "..") {
		min, max := parseUintMinMax(input)

		return &UintMaxMinConstraint{Min: min, Max: max}
	}
	return &UintConstraint{Value: parseUint(input)}
}

func parseUint(input string) uint64 {
	value, err := strconv.ParseUint(strings.TrimSpace(input), 0, 64)
	if err != nil {
		panic(err)
	}
	return value
}

func parseUintMinMax(input string) (uint64, uint64) {
	values := strings.Split(strings.TrimSpace(input), "..")
	if len(values) != 2 {
		err := fmt.Sprintf("Invalid min..max format: '%v'", input)
		panic(err)
	}
	min, err1 := strconv.ParseUint(strings.TrimSpace(values[0]), 0, 64)
	if err1 != nil {
		err := fmt.Sprintf("Invalid 'min' in min..max format: '%v': %v", input, err1)
		panic(err)
	}
	max, err2 := strconv.ParseUint(strings.TrimSpace(values[1]), 0, 64)
	if err2 != nil {
		err := fmt.Sprintf("Invalid 'min' in min..max format: '%v': %v", input, err2)
		panic(err)
	}
	if max < min {
		err := fmt.Sprintf("Invalid 'min' in min..max format, max < min: '%v'", input)
		panic(err)
	}
	return min, max
}

// NewBitFieldConstraint parses an input string and generates an appropriate IConstraint type
// to handle processing.  The input takes on the form of:
//
//    <bitmask>  is a numerical (often hexadecimal) value that specifies the valid bits
//               allowed for the bitmask
//
func NewBitFieldConstraint(input string) *BitmapConstraint {
	input = strings.TrimSpace(input)
	if len(input) > 0 {
		bitmask, err := strconv.ParseUint(input, 0, 64)
		if err != nil {
			panic(err)
		}
		return &BitmapConstraint{Bitmask: bitmask}
	}
	return nil
}

// NewConstraint accepts a textual constraint input and generates the constraint
// object(s) to match it
func NewConstraint(input string, attrType AttributeType) IConstraint {
	switch attrType {
	default:
		// TODO: Log error
		return nil

	case OctetsAttributeType, StringAttributeType, TableAttributeType:
		return NewOctetsConstraint(input)

	case UnsignedIntegerAttributeType, SignedIntegerAttributeType, EnumerationAttributeType,
		PointerAttributeType:
		return NewIntegerConstraint(input)

	case BitFieldAttributeType:
		return NewBitFieldConstraint(input)

	case CounterAttributeType:
		// Counters are read-only, no constraints are required
		return nil
	}
}

// ConstraintsValid validates a value against one or more constraints. If the
// value matches any of the contraints provided, true is returned
func ConstraintsValid(value interface{}, constraint interface{}) bool {
	switch reflect.TypeOf(constraint).Kind() {
	case reflect.Array, reflect.Slice:
		for _, item := range constraint.([]interface{}) {
			if ConstraintsValid(value, item) {
				return true
			}
		}
		return false

	default:
		switch constraint.(type) {
		default:
			return false

		case UintConstraint:
			constraint, _ := constraint.(UintConstraint)
			if constraint.Valid(value) {
				return true
			}

		case UintMaxMinConstraint:
			constraint, _ := constraint.(UintMaxMinConstraint)
			if constraint.Valid(value) {
				return true
			}

		case BitmapConstraint:
			constraint, _ := constraint.(BitmapConstraint)
			if constraint.Valid(value) {
				return true
			}

		case OctetConstraint:
			constraint, _ := constraint.(OctetConstraint)
			if constraint.Valid(value) {
				return true
			}
		}
	}
	return false
}
